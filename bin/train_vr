#!/bin/csh -fb
setenv APP "aah"
setenv API "train"
if ($?TMP == 0) setenv TMP "/var/lib/age-at-home/"

# don't update file information more than once per (in seconds)
setenv TTL 28800
setenv SECONDS `date "+%s"`
setenv DATE `echo $SECONDS \/ $TTL \* $TTL | bc`

set DEBUG = true 

#
# PROCESS CGI QUERY_STRING
#

if ($?QUERY_STRING) then
    set device = `echo "$QUERY_STRING" | sed 's/.*db=\([^&]*\).*/\1/'`
    if ($device == "$QUERY_STRING") unset device
    set model = `echo "$QUERY_STRING" | sed 's/.*model=\([^&]*\).*/\1/'`
    if ($model == "$QUERY_STRING") set model = ""
    set notags = `echo "$QUERY_STRING" | sed 's/.*notags=\([^&]*\).*/\1/'`
    if ($notags == "$QUERY_STRING") set notags = ""
endif

#
# PROCESS COMMAND LINE ARGUMENTS
#

@ i = 1
while ($i <= $#argv)
    set t = "$argv[$i]"
    if (($#t == 1) && ($#argv >= $i)) then
	if ("$t" == "-n") then
	    @ i++
	    set maxfiles = $argv[$i]
	else if ("$t" == "-D") then
	    # delete existing model (must also specify -m <model>)
	    set delete = true
	else if ("$t" == "-m") then
	    @ i++
	    # model by <classifier_id>
	    set model = $argv[$i]
	else if ("$t" == "-j") then
	    @ i++
	    # find by job_id (DATE)
	    setenv DATE $argv[$i]
	else if ("$t" == "-N") then
	    @ i++
	    # negative example class
	    set notags  = $argv[$i]
	else if ("$t" == "-d") then
	    @ i++
	    # base path directory
	    setenv TMP "$argv[$i]"
       else if ($#argv >= $i) then
	   # name of directory in TMP
	   set device = "$argv[$i]"
       endif
    endif
    @ i++
end

#
# defaults (rough-fog)
#
if ($?device == 0) set device = rough-fog
# standardize QUERY_STRING to manage workloads
setenv QUERY_STRING "db=$device"
# ESTABLISH DEFAULT PARAMETERS
if ($?device && $?model && $?notags) then
    echo `date` "$0 $$ -- $device $model $notags" >& /dev/stderr
else
    if ($?device == 0) set device="rough-fog"
    if ($device == "rough-fog" && $?notags == 0) set notags = "kitchen"
    if ($device == "damp-cloud" && $?notags == 0) set notags = "bathroom"
endif

echo `date` "$0 $$ -- START ($QUERY_STRING)" >& /dev/stderr

##
## STEP 1 - INVENTORY
##

set INVENTORY = "$TMP/$APP-$API-$device.$DATE.json"
set INPROGRESS = ( `echo "$INVENTORY".*` )
if ($#INPROGRESS) then
    if ($?DEBUG) echo `date` "$0 $$ -- inventory in-progress ($INPROGRESS)" >& /dev/stderr
    goto done
else if (-s "$INVENTORY") then
    if ($?DEBUG) echo `date` "$0 $$ -- found $INVENTORY" >& /dev/stderr
    goto batch
endif
if ($?DEBUG) echo `date` "$0 $$ -- finding old ($APP-$API-$device.*.json)" >& /dev/stderr
set old = ( `echo "$TMP/$APP-$API-$device".*.json` )
if ($#old > 0) then
    if ($?DEBUG) echo `date` "$0 $$ -- removing old ($old)" >& /dev/stderr
    rm -f $old
endif
# indicate in-progress
if ($?DEBUG) echo `date` "$0 $$ -- creating inventory $INVENTORY" >& /dev/stderr

# note specification of "label" subdirectory
if (! -d "$TMP/label") then
    echo `date` "$0 $$ -- no directory ($TMP/label)" >& /dev/stderr
    exit
endif

echo '{"name":"'$device'","negative":"'$notags'","model":' >! "$INVENTORY.$$"
if ($?model) then
  echo '"'$model'","detail": null',' >> "$INVENTORY.$$"
else
  echo 'null,' >> "$INVENTORY.$$"
endif

echo '"classes":[' >> "$INVENTORY.$$"
# iterate
foreach xdir ( "$TMP/label/$device/"* )
    if ($?DEBUG) echo `date` "$0 $$ -- processing $xdir" >& /dev/stderr
    if ($?set) echo ',' >> "$INVENTORY.$$"
    set set = "$xdir:t"
    echo '{"class":"'$set'","ids":[' >> "$INVENTORY.$$"
    @ count = 0
    @ bytes = 0
    foreach file ( `find "$xdir" -name "*.jpg" -type f -print` )
      if ($count > 0) echo ',' >> "$INVENTORY.$$"
      @ bytes += `ls -l $file | awk '{ print $5 }'`
      echo '"'"$file:t:r"'"' >> "$INVENTORY.$$"
      @ count++
    end
    echo '],"bytes":'$bytes',"count":'$count'}' >> "$INVENTORY.$$"
end
echo ']}' >> "$INVENTORY.$$"
 
jq '.' "$INVENTORY.$$" >! "$INVENTORY"

rm -f "$INVENTORY.$$"

##
## STEP 2 - CALCULATE BATCH JOBS
##

batch:

set JOB = "$TMP/$APP-$API-$device.$DATE.job"
set INPROGRESS = ( `echo "$JOB".*` )
if ($#INPROGRESS) then
    if ($?DEBUG) echo `date` "$0 $$ -- batching in-progress ($INPROGRESS)" >& /dev/stderr
    goto done
else if (-d "$JOB") then
    if ($?DEBUG) echo `date` "$0 $$ -- existing batches ($JOB)" >& /dev/stderr
    goto train
endif
set old = ( `echo "$TMP/$APP-$API-$device".*.job` )
if ($#old > 0) then
    if ($?DEBUG) echo `date` "$0 $$ -- NOT removing old ($old)" >& /dev/stderr
    # rm -fr $old
endif
# indicate JOB in-progress
if ($?DEBUG) echo `date` "$0 $$ -- batching jobs $JOB" >& /dev/stderr
touch "$JOB.$$"
mkdir -p "$JOB"

#
# WATSON VISUAL RECOGNITION - INSTRUCTIONS
#
# SIZE LIMITATIONS (enforced by API)
# 
# The service accepts a maximum of 10,000 images or 100 MB per .zip file
# The service requires a minimum of 10 images per .zip file.
# The service accepts a maximum of 256 MB per training call.
#
# GUIDELINES (not enforced)
#
# Include approximately the same number of images in each examples file.
# Including an unequal number of images can cause the quality of the trained classifier to decline. 
#
# 1) A minimum of 50 images is recommended in each .zip file, as fewer than 50 images can decrease the quality of the trained classifier.
# 2) If the quality and content of training data is the same, then classifiers that are trained on more images will generally be more accurate 
#    than classifiers that are trained on fewer images. The benefits of training a classifier on more images plateaus at around 5000 images, 
#    and this can take a while to process. You can train a classifier on more than 5000 images, but it may not significantly increase that classifier's accuracy.
# 3) Uploading a total of 150-200 images per .zip file gives you the best balance between the time it takes to train and the improvement to classifier accuracy. 
#    More than 200 images increases the time, and it does increace the accuracy, but with diminishing returns for the amount of time it takes.
#
# ADDITIONAL TRAINING AND TESTING INSTRUCTIONS
#
# Split into two or three sets: training, validation (for hyper-parameters) and testing (http://sebastianraschka.com/blog/2016/model-evaluation-selection-part3.html)
#
@ MAXIMAGES = 10000
@ MAXZIPBYTES = 100 * 1000 * 1000
@ MINIMAGES = 10
@ MAXSETBYTES = 256 * 1000 * 1000
@ MINSETSIZE = 50
@ MAXSETSIZE = 5000
@ MAXZIPSET = 200
@ SPLITSETS = 2

# get all classes as pairs of class name and count (including negative)
set allclass = ( `jq '[.classes|sort_by(.count)[]|{"class":.class,"count":.count,"bytes":.bytes}]' "$INVENTORY"`)
if ($?DEBUG) echo `date` "$0 $$ -- batching classes by counts ($allclass)" >& /dev/stderr

# process all samples into training, validation and test sets
set pairs = ( `echo "$allclass" | jq '.[]|.class,.count' | sed 's/"//g'` )
if ($#pairs > 0) then
  @ p = 1
  echo 
  set job = '{"device":"'"$device"'","job":'"$DATE"',"classes":['
  while ($p < $#pairs) 
    set class = $pairs[$p]
    @ p++
    set count = $pairs[$p]
    @ p++
    if ($?DEBUG) echo `date` "$0 $$ -- CLASS ($class) COUNT ($count)" >& /dev/stderr
    # calculate split size to create only SPLITSETS number of sets
    @ split = ( $count / $SPLITSETS ) + ( $count % $SPLITSETS )
    # test is split size is sufficient
    if ($split > $MINIMAGES) then
      # test if too many samples
      if ($split > $MAXSETSIZE) then
	if ($?DEBUG) echo `date` "$0 $$ -- split size ($MAXSETSIZE); actual ($split)" >& /dev/stderr
	set split = MAXSETSIZE
      else
	if ($?DEBUG) echo `date` "$0 $$ -- split size ($split)" >& /dev/stderr
      endif
      set base = "$JOB/$class." 
      jq '.classes[]|select(.class=="'$class'").ids[]' "$INVENTORY" | sed 's/"//g' | split -l $split - $base 
      set split = ( `echo $base*` )
      if ($?sets) then
	set sets = "$sets"'},{"class":"'"$class"'","sets":'
      else
	set sets = '{"class":"'"$class"'","sets":'
      endif
    else
      if ($?DEBUG) echo `date` "$0 $$ -- insufficient samples ($split)" >& /dev/stderr
      unset split
    endif
    if ($?split) then
      if ($?DEBUG) echo `date` "$0 $$ -- processing ($split)" >& /dev/stderr
      foreach s ( $split )
        if ($?splits) then
	  set splits = "$splits"','
	else
	  set splits = '['
	endif
	set ext = $s:e
	# create ZIP file name 
	set zip = "$JOB/$class.zip"
	if ($?DEBUG) echo `date` "$0 $$ -- creating ($zip) from split ($s)" >& /dev/stderr
	foreach id ( `cat "$s"` )
	  # slow but complete
	  find $TMP/label/$device -name "$id".jpg -print | xargs -I % zip -q -j -r -u "$zip" % >& /dev/stderr
	end
	rm -f "$s"
	if (-s "$zip") then
	  # put all results into temporary directory
	  set base = "$JOB/$class"
	  mkdir -p "$base"
	  if ($?DEBUG) echo `date` "$0 $$ -- splitting ($zip) into ($base)" >& /dev/stderr
	  zipsplit -b "$base/" -n $MAXZIPBYTES "$zip" >& /dev/null
	  # success?
	  if ($status == 0) then
	    # get all the zips created
	    set zips = ( `echo "$base/"*.zip` )
	    if ($#zips > 0) then
	      if ($?DEBUG) echo `date` "$0 $$ -- split into $#zips ZIP files ($zips)" >& /dev/stderr
	      @ i = 1
	      foreach z ( $zips )
	        set b = "$JOB/$class.$ext.$i.zip"
		if ($?DEBUG) echo `date` "$0 $$ -- creating batch entry ($b)" >& /dev/stderr
	        mv "$z" "$b"
		if ($?batch) then
		    set batch = "$batch"',"'"$b"'"'
		else
		    set batch = '["'"$b"'"'
		endif
		@ i++
	      end
	      set batch = "$batch"']'
	      if ($?DEBUG) echo `date` "$0 $$ -- BATCH: $batch" >& /dev/stderr
	    else
	      if ($?DEBUG) echo `date` "$0 $$ -- NO ZIPS" >& /dev/stderr
	      unset zips
	      exit
	    endif
	  else
	    if ($?DEBUG) echo `date` "$0 $$ -- ZIPSPLIT failure" >& /dev/stderr
	    exit
	  endif
	  rm -fr "$base"
	else
	  if ($?DEBUG) echo `date` "$0 $$ -- ZIP failure" >& /dev/stderr
	  exit
	endif
	if ($?zips) then
	  unset zips
	endif
	rm -f "$zip"
	set splits = "$splits""$batch"
	unset batch
      end
    else
      if ($?DEBUG) echo `date` "$0 $$ -- NO SPLIT ($split)" >& /dev/stderr
      exit
    endif
    set sets = "$sets""$splits"']'
    unset splits
  end
  set job = "$job""$sets"'}]}'
else
  if ($?DEBUG) echo `date` "$0 $$ -- NO PAIRS" >& /dev/stderr
  exit
endif

# store result
echo "$job" >! "$JOB/job.json"

# all done
rm -f "$JOB.$$"

##
## STEP 3 - EXECUTING TRAINING JOBS
##

train:

if ($?DEBUG) echo `date` "$0 $$ -- TRAIN" >& /dev/stderr

set TRAIN = "$TMP/$APP-$API-$device.$DATE.job/train"
set INPROGRESS = ( `echo "$TRAIN".*` )
if ($#INPROGRESS) then
    if ($?DEBUG) echo `date` "$0 $$ -- training in-progress ($INPROGRESS)" >& /dev/stderr
    goto done
else if (-d "$TRAIN") then
    if ($?DEBUG) echo `date` "$0 $$ -- existing training ($TRAIN)" >& /dev/stderr
    goto train
endif
set old = ( `echo "$TMP/$APP-$API-$device.$DATE.job/train".*.json` )
if ($#old > 0) then
    if ($?DEBUG) echo `date` "$0 $$ -- NOT removing old ($old)" >& /dev/stderr
    # rm -fr $old
endif

# check requisites
set INVENTORY = "$TMP/$APP-$API-$device.$DATE.json"
set JOB = "$TMP/$APP-$API-$device.$DATE.job"
if ((-s "$INVENTORY") && (-d "$JOB")) then
    if ($?DEBUG) echo `date` "$0 $$ -- found inventory ($INVENTORY) and job ($JOB)" >& /dev/stderr
else 
    if ($?DEBUG) echo `date` "$0 $$ -- no inventory ($INVENTORY) or job ($JOB)" >& /dev/stderr
    goto done
endif

# get parameters
set device = ( `jq '.name' "$INVENTORY" | sed 's/"//g'` )

if ($?DEBUG) echo `date` "$0 $$ -- device ($device)" >& /dev/stderr

#
# SETUP WATSON VISUAL_RECOGNITION
#

set creds = ~$USER/.watson.visual-recognition.json
if (-e $creds) then
    set keys = ( `jq '.[]|.credentials.api_key' $creds` )
    if ($#keys > 0) set api_key = `echo "$keys[1]" | sed 's/"//g'`
    set urls = ( `jq '.[]|.credentials.url' $creds` )
    if ($#urls > 0) set TU = `echo "$urls[1]" | sed 's/"//g'`
else 
    echo `date` "$0 $$ -- NO CREDENTIALS ($creds); create file and copy credentials from visual-recognition service on bluemix.net" >& /dev/stderr
    goto done
endif
# these should be query'able from the API
if ($?verid == 0) set verid = "v3"
if ($?vdate == 0) set vdate = "2016-05-20"

if ($?DEBUG) echo `date` "$0 $$ -- Watson VisualRecognition for version ($verid) - date ($vdate) @ ($TU)" >& /dev/stderr

#
# GET EXISTING CLASSIFIERS FROM WATSON_VR
#

if ($?model) then
    if ($?DEBUG) echo `date` "$0 $$ -- searching for classifier by ID" >& /dev/stderr
    set classifiers = ( `curl -q -s -L "$TU/$verid/classifiers?api_key=$api_key&version=$vdate" | jq '[.classifiers[]|select(.classifier_id=="'"$model"'")]'` )
    if ($?DEBUG) echo `date` "$0 $$ -- got ($classifiers) for $model on $device" >& /dev/stderr
else if ($?device) then
    if ($?DEBUG) echo `date` "$0 $$ -- searching for classifier by device" >& /dev/stderr
    set classifiers = ( `curl -q -s -L "$TU/$verid/classifiers?api_key=$api_key&version=$vdate" | jq '[.classifiers[]|select(.name=="'"$device"'")]'` )
    set model = ( `echo "$classifiers" | jq '.[].classifier_id' | sed 's/"//g'` )
    if ($#model > 0) then
      if ($?DEBUG) echo `date` "$0 $$ -- using $model[1] from $device for classifier by device" >& /dev/stderr
      set model = $model[1]
    else
      unset model
    endif
endif

if ($?classifiers) then
    if ($?DEBUG) echo `date` "$0 $$ -- CLASSIFIERS ($classifiers)" >& /dev/stderr
else
    if ($?DEBUG) echo `date` "$0 $$ -- NO EXISTING CLASSIFIERS" >& /dev/stderr
    set classifiers = ()
endif

#
# TEST CLASSIFIER STATUS (ready or training)
#

if ($#classifiers > 0 && $?model) then
    set ready = ( `echo "$classifiers" | jq '[.[]|select(.status=="ready")]'` )
    set cids = `echo "$classifiers" | jq '.[]|select(.classifier_id=="'"$model"'").classifier_id' | sed 's/"//g'`
    if ($#cids > 0) then
      foreach cid ( $cids )
	if ($cid == "$model") then
	    if ($?DEBUG) echo `date` "$0 $$ -- matched specified classifier ($model)" >& /dev/stderr
	    if ($?delete) then
		if ($?DEBUG) echo `date` "$0 $$ -- deleting classifier id ($cid)" >& /dev/stderr
		curl -s -q -X DELETE "$TU/$verid/classifiers/$cid?api_key=$api_key&version=$vdate"
		unset model
	    else
		if ($?DEBUG) echo `date` "$0 $$ -- getting details for classifier id ($cid)" >& /dev/stderr
		set detail = ( `curl -s -q "$TU/$verid/classifiers/$cid?api_key=$api_key&version=$vdate" | jq '.'` )
	    endif
	    break
	endif
      end
      # test if model matched (and not deleted)
      if ($?model) then
        if ($cid != "$model") then
	  if ($?DEBUG) echo `date` "$0 $$ -- no classifier ($model) for device ($device) is ready" >& /dev/stderr
	  set training = ( `echo "$classifiers" | jq '[.[]|select(.status=="training")]'` )
	  set cids = ( `echo $training | jq '.[]|select(.name=="'"$model"'").classifier_id' | sed 's/"//g'` )
	  if ($?DEBUG) echo `date` "$0 $$ -- classifiers ($cids) are in training" >& /dev/stderr
	  foreach cid ( $cids )
	      if ($cid == "$model") then
		  if ($?DEBUG) echo `date` "$0 $$ -- classifier id ($cid) in training" >& /dev/stderr
		  goto done
	      endif
	  end
	  # no matching model
	  unset model
	endif
      endif
    endif
endif

#
# GET CLOUDANT SETUP
#
if (-e ~$USER/.cloudant_url) then
    set cc = ( `cat ~$USER/.cloudant_url` )
    if ($#cc > 0) set CU = $cc[1]
    if ($#cc > 1) set CN = $cc[2]
    if ($#cc > 2) set CP = $cc[3]
endif
if ($?CLOUDANT_URL) then
    set CU = $CLOUDANT_URL
else if ($?CN && $?CP) then
    set CU = "$CN":"$CP"@"$CN.cloudant.com"
else
    echo `date` "$0 $$ -- no Cloudant URL" >& /dev/stderr
    goto done
endif
# logic doesn't work if model is null
if ($?model) then
    set oldmodel = `curl -s -q -L "$CU/$API-$device/$model" | jq '.'`
    set doc = ( `echo "$oldmodel" | jq '._id,._rev' | sed 's/"//g'` )
    if ($#doc == 2 && $doc[1] == $model && $doc[2] != "") then
	set known = ( `echo "$oldmodel" | jq '.classes[].class' | sed 's/"//g'` )
    else
        if ($?DEBUG) echo `date` "$0 $$ -- no stored model ($oldmodel)" >& /dev/stderr
    endif
endif

#
# GET CLASSES (OLD, NET, NEGATIVE)
#

if ($?detail) then
    if ($?DEBUG) echo `date` "$0 $$ -- model details ($detail)" >& /dev/stderr
    set oldclasses = ( `echo "$detail" | jq '.classes[].class' | sed 's/"//g'` )
else
    unset oldclasses
endif

set newclasses = ( `jq '.classes[].class' "$INVENTORY" | sed 's/"//g'` )
set notags = ( `jq '.negative' "$INVENTORY" | sed 's/"//g'` )

set net = ()
foreach nc ( $newclasses )
    if ($?oldclasses && $nc != "$notags") then
	foreach oc ( $oldclasses )
	    if ($nc == "$oc") break
	end
	if ($nc != "$oc") then
	    set net = ( $net $nc )
	endif
    else if ($nc != "$notags") then
	set net = ( $net $nc )
    endif
end 

if ($?DEBUG) echo `date` "$0 $$ -- OLD ($?oldclasses) NEW ($net) NEGATIVE ($notags) +++" >& /dev/stderr

#
# work out runs
#

set positive = ( `jq '.classes|sort_by(.count)[]|select(.class!="'$notags'")|.class' "$INVENTORY" | sed 's/"//g'` )
set negative = ( `jq '.classes|sort_by(.count)[]|select(.class=="'$notags'")|.class' "$INVENTORY" | sed 's/"//g'` )
set negatives = ( `jq '.classes[]|select(.class=="'"$notags"'").sets[0][]' "$JOB/job.json" | sed 's/"//g'` )

@ h = 1
@ j = 1
while ($h <= $#positive) 
  set p = $positive[$h]
  # first (0) set is training
  set positives = ( `jq '.classes[]|select(.class=="'"$p"'").sets[0][]' "$JOB/job.json" | sed 's/"//g'` )
  @ i = 1
  while ($i <= $#positives) 
    set job = "$JOB/$p.$$.json"
    if ($?negatives) then
      set examples = ( -F "$p""_positive_examples=@$positives[$i]" -F "negative_examples=@$negatives[$j]" )
    else if ($?model) then
      set examples = ( -F "$p""_positive_examples=@$positives[$i]" )
    else
      echo `date` "$0 $$ ** INSUFFICIENT EXAMPLE SETS **"
      exit
    endif
again:
    # timer start
    @ start = `date +%s`
    # run training 
    if ($?model) then
      if ($?DEBUG) echo `date` "$0 $$ -- RETRAIN $model ($examples)" >& /dev/stderr
      curl -f -s -q -S -L "$TU/$verid/classifiers/$model?api_key=$api_key&version=$vdate" -o $job $examples >& /dev/stderr
    else
      if ($?DEBUG) echo `date` "$0 $$ -- CREATE $device ($examples)" >& /dev/stderr
      curl -f -s -q -S -L "$TU/$verid/classifiers?api_key=$api_key&version=$vdate" -F "name=$device" -o $job $examples >& /dev/stderr
    endif
    set cstatus = $status
    # check status
    if ($cstatus != 0) then
      echo `date` "$0 $$ ** FAILURE ($cstatus)" >& /dev/stderr
      if (-s "$job") then
	  echo `date` "$0 $$ ** " `cat "$job"` >& /dev/stderr
	  # check result code
	  set code = `jq '.code' "$job" | sed 's/"//g'` 
	  set message = `jq '.error' "$job" | sed 's/"//g'`
	  if ($?DEBUG) echo `date` "$0 $$ -- FAILURE ($message)" >& /dev/stderr
      endif
      goto next
    else if (! -s "$job") then
      echo `date` "$0 $$ ** no output ($job)" >& /dev/stderr
      rm -f "$job"
      goto again
    else 
      # check result code
      set code = `jq '.code' "$job" | sed 's/"//g'` 
      if ($code == 400) then
	set message = `jq '.error' "$job" | sed 's/"//g'`
	if ($?DEBUG) echo `date` "$0 $$ -- FAILURE ($message)" >& /dev/stderr
	goto next
      endif
      # get classifier id to check on progress
      set cid = `jq '.classifier_id' "$job" | sed 's/"//g'`
      set sts = `jq '.status' "$job" | sed 's/"//g'`
      if ($#cid > 0 && $cid != "null" && $sts != "error") then
	if ($?DEBUG) echo `date` "$0 $$ -- LEARNING ($cid) status ($sts)" >& /dev/stderr
      else
	echo -n `date` "$0 $$ ** FAILURE ($cid) ($sts) ($job)" >& /dev/stderr
	goto next
      endif
    endif
    if ($?DEBUG) echo -n "+++ WAITING "
    while ($sts != "ready") 
	set sts = ( `curl -s -q -L "$TU/$verid/classifiers/$cid?api_key=$api_key&version=$vdate" | jq '.status' | sed 's/"//g'` )
	if ($sts != "null") then
	  if ($?DEBUG) echo -n "."
	else
	  if ($?DEBUG) echo -n "!"
	endif
        sleep 10
    end
    @ elapsed = `date +%s` - $start
    if ($?DEBUG) echo " ($elapsed seconds) +++"
    set model = "$cid"

next:
    # increment to next batch
    @ i++
    @ j++
    if ($?negatives) then
      if ($j <= $#negatives) then
	set negatives = ( $negatives[$j-] )
      else
	unset negatives
      endif
    endif
  end
  @ h++
end

if ($?DEBUG) echo `date` "$0 $$ -- COMPLETE ($model)" >& /dev/stderr

set classifier = ( `curl -s -q -L "$TU/$verid/classifiers/$model?api_key=$api_key&version=$vdate" | jq '.'` )

exit

#
# INITIATE TRAINING
#

echo "+++ TRAIN $negative $positive +++"
echo 'curl -L -q -s "'"$TU/$verid/classifiers?api_key=$api_key&version=$vdate"'" -o /tmp/'$0:t.$$'.json -F "name='"$xdir:h:t"'"' "$positive" "$negative" >! /tmp/$0:t.$$.sh
echo "++++ RUNNING: " `cat /tmp/$0:t.$$.sh`
sh /tmp/$0:t.$$.sh
# cleanup
rm -f /tmp/$0:t.$$.sh
rm -f $xzips

# check result code
set code = `jq '.code' /tmp/$0:t.$$.json | sed 's/"//g'` 
if ($code == 400) then
    jq '.error' /tmp/$0:t.$$.json
    goto done
endif

# get classifier id to check on progress
set cid = `jq '.classifier_id' /tmp/$0:t.$$.json | sed 's/"//g'`
set sts = `jq '.status' /tmp/$0:t.$$.json | sed 's/"//g'`

#
# WAIT FOR COMPLETION
#

onintr done

goto done

#
# update Cloudant
#
if ($?CLOUDANT_OFF == 0 && $?CU && $?device) then
    if ($?DEBUG) echo `date` "$0 $$ -- test if device exists ($CU/$device-$API)" >>! /tmp/LOG
    set DEVICE_device = `curl -s -q -X GET "$CU/$device-$API" | jq '.db_name'`
    if ( "$DEVICE_device" == "null" ) then
        if ($?DEBUG) echo `date` "$0 $$ -- creating device $CU/$device-$API" >>! /tmp/LOG
        # create device
        set DEVICE_device = `curl -s -q -X PUT "$CU/$device-$API" | jq '.ok'`
        # test for success
        if ( "$DEVICE_device" != "true" ) then
            # failure
            if ($?DEBUG) echo `date` "$0 $$ -- failure creating Cloudant database ($device-$API)" >>! /tmp/LOG
            setenv CLOUDANT_OFF TRUE
        else
            if ($?DEBUG) echo `date` "$0 $$ -- success creating device $CU/$device-$API" >>! /tmp/LOG
        endif
    endif
    if ( $?CLOUDANT_OFF == 0 ) then
        curl -s -q -o "$OLD" "$CU/$device-$API/$model" >>&! /tmp/LOG
        if (-s "$OLD") then
            set doc = ( `cat "$OLD" | jq ._id,._rev | sed 's/"//g'` )
            if ($#doc == 2 && $doc[1] == $model && $doc[2] != "") then
                set rev = $doc[2]
                if ($?DEBUG) echo `date` "$0 $$ -- deleting old output ($rev)" >>! /tmp/LOG
                curl -s -q -X DELETE "$CU/$device-$API/$model?rev=$rev" >>&! /tmp/LOG
            endif
        else
            if ($?DEBUG) echo `date` "$0 $$ -- no old output to delete" >>! /tmp/LOG
        endif
        if ($?DEBUG) echo `date` "$0 $$ -- storing new output" >>! /tmp/LOG
        curl -s -q -H "Content-type: application/json" -X PUT "$CU/$device-$API/$model" -d "@$INVENTORY" >>&! /tmp/LOG
        if ($status == 0) then
            if ($?DEBUG) echo `date` "$0 $$ -- success storing new output" >>! /tmp/LOG
        else
            if ($?DEBUG) echo `date` "$0 $$ -- failure storing new output" >>! /tmp/LOG
        endif
    else
        if ($?DEBUG) echo `date` "$0 $$ -- Cloudant OFF ($device-$API)" >>! /tmp/LOG
    endif
else
    if ($?DEBUG) echo `date` "$0 $$ -- no Cloudant update" >>! /tmp/LOG
endif

done:

rm -f /tmp/$0:t.$$.json

echo `date` "$0 $$ -- FINISH ($*)"
